<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: files/storages/memory.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: files/storages/memory.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {FileNotFoundError, AbstractFileStorage} from "./base.js";

if (Object.values === undefined){
  // Polyfill for testing with Node versions &lt; 7.0.
  Object.values = (obj) => Object.keys(obj).map(key => obj[key]);
}

class BaseMemoryFile {
  constructor(parent, name){
    this._name = name;
    this._created = new Date();
    this.parent = parent;
  }

  static get directory(){
    return false;
  }

  get parent(){
    return this._parent;
  }

  set parent(parent){
    if (this._parent){
      this._parent.removeChild(this.name);
    }
    if (parent !== null){
      parent.addChild(this);
    }
    this._parent = parent
  }

  get id(){
    if (this.parent === null){
      // Root directory
      return "";
    }
    return this.parent.id + '/' + this.name;
  }

  get name(){
    return this._name;
  }

  get icon(){
    return null;
  }

  get url(){
    return "";
  }

  get created(){
    return this._created.toISOString();
  }

  /**
   * @abstract
   */
  get file(){
    throw new Error("Not implemented");
  }

  /**
   * @abstract
   */
  get size(){
    throw new Error("Not implemented");
  }

  /**
   * @abstract
   */
  get mimeType(){
    throw new Error("Not implemented");
  }

  /**
   * @abstract
   */
  get lastModified(){
    throw new Error("Not implemented");
  }

  /**
   * @abstract
   */
  get children(){
    throw new Error("Not implemented");
  }

  get fileNode(){
    return {
      id: this.id,
      name: this.name,
      url: this.url,
      directory: this.constructor.directory,
      icon: this.icon,
      size: this.size,
      mimeType: this.mimeType,
      lastModified: this.lastModified,
      created: this.created
    };
  }

  rename(name){
    this.parent.removeChild(this.name);
    this._name = name;
    this.parent.addChild(this.name);
  }
}

class MemoryFile extends BaseMemoryFile {
  constructor(parent, file){
    super(parent, file.name);

    this.file = file;
  }

  get file(){
    return this._file;
  }

  set file(file){
    if (!(file instanceof File)) {
      let type = file.type || 'application/octet-stream';
      file = new File([file], filename, {type: type});
    }
    this._file = file;
  }

  get size(){
    return this._file.size;
  }

  get mimeType(){
    return this._file.mimeType;
  }

  get lastModified(){
    return new Date(this._file.lastModified).toISOString();
  }

  get children(){
    return {};
  }
}

class MemoryDirectory extends BaseMemoryFile {
  constructor(parent, name){
    super(parent, name);
    this._children = {};
  }

  static get directory(){
    return true;
  }

  get file(){
    let nodes = {};
    for (let name in this._children){
      nodes[name] = this._children[name].fileNode;
    }
    return new File([JSON.stringify(nodes)], this.name, {type: 'application/json'});
  }

  get size(){
    let size = 0;
    for (let child of Object.values(this._children)){
      size += child.size;
    }
    return size;
  }

  get lastModified(){
    let children = Object.values(this._children);
    if (children.length === 0){
      return this.created;
    }
    return new Date(Math.max.apply(null, Object.values(this._children).map(function(e) {
      return new Date(e.lastModified);
    }))).toISOString();
  }

  get mimeType(){
    return 'application/json';
  }

  get children(){
    return this._children;
  }

  addChild(memoryFile){
    this._children[memoryFile.name] = memoryFile;
  }

  removeChild(name){
    delete this._children[name];
  }
}

export class MemoryFileStorage extends AbstractFileStorage {
  /**
   * This storage stores file temporary in memory on the client.
   */
  constructor(){
    super();

    this._root = new MemoryDirectory(null, 'root');
  }

  get rootFileNode(){
    return this._root.fileNode;
  }

  async readFileNode(fileNode, params) {
    let memoryFile = this._getFile(fileNode.id);
    return memoryFile.file;
  }


  _stringToPathArray(stringPath){
    stringPath = stringPath.trim();
    if (stringPath === ""){
      return [];
    }
    return stringPath.split('/');
  }

  _normalizePath(path){
    let pathArray = this._stringToPathArray(path);
    let normalizedPathArray = [];
    for (let segement of pathArray){
      if (segement.trim() !== ""){
        normalizedPathArray.push(segement.toString());
      }
    }
    return normalizedPathArray.join('/');
  }

  _getFile(path){
    path = this._normalizePath(path);
    let pathArray = this._stringToPathArray(path);
    let memoryFile = this._root;
    let index = 0;
    while (index &lt; pathArray.length){
      let segment = pathArray[index];
      if (segment){
        memoryFile = memoryFile.children[segment];
        if (memoryFile === undefined){
          throw new FileNotFoundError(`File not found at ${path}.`);
        }
      }
      index ++;
    }
    return memoryFile;
  }

  async addFile(parentNode, file, filename){
    let parent = this._getFile(parentNode.id);
    if (file.name &amp;&amp; (filename !== file.name)){
      file = new File([file], filename, {type: file.type});
    }
    let newMemoryFile = new MemoryFile(parent, file);
    return newMemoryFile.fileNode;
  }

  async writeFileNode(fileNode, data) {
    let memoryFile = this._getFile(fileNode.id);
    memoryFile.file = new File([data], memoryFile.name);
    return memoryFile.fileNode;
  }

  async addDirectory(parentNode, name) {
    let parent = this._getFile(parentNode.id);
    let newMemoryDirectory = new MemoryDirectory(parent, name);
    return newMemoryDirectory.fileNode;
  }

  async rename(fileNode, newName) {
    let memoryFile = this._getFile(fileNode.id);
    memoryFile.rename(newName);
  }

  async delete(fileNode) {
    let memoryFile = this._getFile(fileNode.id);
    let parent = memoryFile.parent;
    parent.removeChild(memoryFile.name);
  }

  async copy(source, targetParent) {
    let sourceMemoryFile = this._getFile(source.id);
    let targetMemoryFile = this._getFile(targetParent.id);
    if (sourceMemoryFile.directory){
      new MemoryDirectory(targetMemoryFile, source.name);
    } else {
      new MemoryFile(targetMemoryFile, new File([source.file], source.name, {type: source.type}));
    }
  }

  async move(source, targetParent) {
    let sourceMemoryFile = this._getFile(source.id);
    sourceMemoryFile.parent = this._getFile(targetParent.id);
  }

  async search(query) {
    throw new Error("Not implemented")
  }

  clone() {
    throw new Error("Not implemented")
  };
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AbstractFileStorage_AbstractFileStorage.html">AbstractFileStorage</a></li><li><a href="BaseFileSystem_BaseFileSystem.html">BaseFileSystem</a></li><li><a href="Column.html">Column</a></li><li><a href="DialogBrowser_DialogBrowser.html">DialogBrowser</a></li><li><a href="Element.html">Element</a></li><li><a href="FileAPIFileStorage_FileAPIFileStorage.html">FileAPIFileStorage</a></li><li><a href="FileBrowser_FileBrowser.html">FileBrowser</a></li><li><a href="FileObject_FileObject.html">FileObject</a></li><li><a href="Link_Link.html">Link</a></li><li><a href="LocalStorageFileStorage_LocalStorageFileStorage.html">LocalStorageFileStorage</a></li><li><a href="MemoryFileStorage_MemoryFileStorage.html">MemoryFileStorage</a></li><li><a href="PhotoshelterStorage_PhotoshelterStorage.html">PhotoshelterStorage</a></li><li><a href="Row.html">Row</a></li><li><a href="Table.html">Table</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-QuickStartTutorial.html">Quick Start</a></li><li><a href="tutorial-UserInterfaceTutorial.html">User Interface</a></li></ul><h3>Global</h3><ul><li><a href="global.html#CacheMixin">CacheMixin</a></li><li><a href="global.html#changeDirectory">changeDirectory</a></li><li><a href="global.html#data">data</a></li><li><a href="global.html#dataUrlToBlob">dataUrlToBlob</a></li><li><a href="global.html#DraggableMixin">DraggableMixin</a></li><li><a href="global.html#DroppableMixin">DroppableMixin</a></li><li><a href="global.html#exec">exec</a></li><li><a href="global.html#execFileObject">execFileObject</a></li><li><a href="global.html#ExecutableMixin">ExecutableMixin</a></li><li><a href="global.html#executablePath">executablePath</a></li><li><a href="global.html#fileToDataUrl">fileToDataUrl</a></li><li><a href="global.html#HiddenFileAPIMixin">HiddenFileAPIMixin</a></li><li><a href="global.html#HiddenReferenceLinkMixin">HiddenReferenceLinkMixin</a></li><li><a href="global.html#import">import</a></li><li><a href="global.html#importFromFileObject">importFromFileObject</a></li><li><a href="global.html#MountStorageMixin">MountStorageMixin</a></li><li><a href="global.html#parseConfigFile">parseConfigFile</a></li><li><a href="global.html#parseJsonFile">parseJsonFile</a></li><li><a href="global.html#parseTextFile">parseTextFile</a></li><li><a href="global.html#path">path</a></li><li><a href="global.html#refresh">refresh</a></li><li><a href="global.html#refreshAfter">refreshAfter</a></li><li><a href="global.html#StateMixin">StateMixin</a></li><li><a href="global.html#updateConfigFile">updateConfigFile</a></li><li><a href="global.html#waitFor">waitFor</a></li><li><a href="global.html#waitOn">waitOn</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
