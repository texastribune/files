<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: files/storages/memory.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: files/storages/memory.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {FileNotFoundError, AbstractFileStorage} from "./base.js";
import {stringToArrayBuffer, copyArrayBuffer} from "../../utils.js";

if (Object.values === undefined){
  // Polyfill for testing with Node versions &lt; 7.0.
  Object.values = (obj) => Object.keys(obj).map(key => obj[key]);
}

class BaseMemoryFile {
  constructor(parent, name, mimeType){
    this._name = name;
    this._mimeType = mimeType;
    this._created = new Date();
    this._lastModified = new Date();
    this.parent = parent;
  }

  static get directory(){
    return false;
  }

  get parent(){
    return this._parent;
  }

  set parent(parent){
    if (this._parent){
      this._parent.removeChild(this.name);
    }
    if (parent !== null){
      parent.addChild(this);
    }
    this._parent = parent
  }

  get mimeType(){
    return this._mimeType || 'application/octet-stream';
  }

  get id(){
    if (this.parent === null){
      // Root directory
      return "";
    }
    return this.parent.id + '/' + this.name;
  }

  get name(){
    return this._name;
  }

  get icon(){
    return null;
  }

  get url(){
    return "";
  }

  get created(){
    return this._created.toISOString();
  }

  get lastModified(){
    return this._lastModified.toISOString();
  }

  /**
   * @abstract
   * @returns ArrayBuffer
   */
  get fileData(){
    throw new Error("Not implemented");
  }

  /**
   * @abstract
   * @returns int
   */
  get size(){
    throw new Error("Not implemented");
  }

  /**
   * @abstract
   */
  get children(){
    throw new Error("Not implemented");
  }

  get fileNode(){
    return {
      id: this.id,
      name: this.name,
      url: this.url,
      directory: this.constructor.directory,
      icon: this.icon,
      size: this.size,
      mimeType: this.mimeType,
      lastModified: this.lastModified,
      created: this.created
    };
  }

  rename(name){
    this.parent.removeChild(this.name);
    this._name = name;
    this.parent.addChild(this.name);
  }
}

class MemoryFile extends BaseMemoryFile {
  constructor(parent, name, fileData, mimeType) {
    super(parent, name, mimeType);

    if (!(fileData instanceof ArrayBuffer)){
      throw new Error(`File data must be an ArrayBuffer not ${typeof fileData}.`);
    }
    this._fileData = fileData;
  }

  get fileData(){
    return this._fileData;
  }

  set fileData(data){
    this._fileData = data;
    this._lastModified = new Date();
  }

  get size(){
    return this._fileData.size;
  }

  get lastModified(){
    return this._lastModified.toISOString();
  }

  get children(){
    return {};
  }
}

class MemoryDirectory extends BaseMemoryFile {
  constructor(parent, name){
    super(parent, name, 'application/json');
    this._children = {};
  }

  static get directory(){
    return true;
  }

  get fileData(){
    let nodes = {};
    for (let name in this._children){
      nodes[name] = this._children[name].fileNode;
    }
    return stringToArrayBuffer(JSON.stringify(nodes));
  }

  get size(){
    let size = 0;
    for (let child of Object.values(this._children)){
      size += child.size;
    }
    return size;
  }

  get lastModified(){
    let children = Object.values(this._children);
    if (children.length === 0){
      return this.created;
    }
    return new Date(Math.max.apply(null, Object.values(this._children).map(function(e) {
      return new Date(e.lastModified);
    }))).toISOString();
  }

  get children(){
    return this._children;
  }

  addChild(memoryFile){
    this._children[memoryFile.name] = memoryFile;
  }

  removeChild(name){
    delete this._children[name];
  }
}

/**
 * A storage class that stores file temporary in memory on the client.
 * @extends AbstractFileStorage
 */
export class MemoryFileStorage extends AbstractFileStorage {
  constructor(){
    super();

    this._root = new MemoryDirectory(null, 'root');
  }

  async getRootFileNode(){
    return this._root.fileNode;
  }

  async readFileNode(id, params) {
    let memoryFile = this._getFile(id);
    return memoryFile.fileData;
  }


  _stringToPathArray(stringPath){
    stringPath = stringPath.trim();
    if (stringPath === ""){
      return [];
    }
    return stringPath.split('/');
  }

  _normalizePath(path){
    let pathArray = this._stringToPathArray(path);
    let normalizedPathArray = [];
    for (let segement of pathArray){
      if (segement.trim() !== ""){
        normalizedPathArray.push(segement.toString());
      }
    }
    return normalizedPathArray.join('/');
  }

  _getFile(path){
    path = this._normalizePath(path);
    let pathArray = this._stringToPathArray(path);
    let memoryFile = this._root;
    let index = 0;
    while (index &lt; pathArray.length){
      let segment = pathArray[index];
      if (segment){
        memoryFile = memoryFile.children[segment];
        if (memoryFile === undefined){
          throw new FileNotFoundError(`File not found at ${path}.`);
        }
      }
      index ++;
    }
    return memoryFile;
  }

  async addFile(id, fileData, filename, mimeType){
    let parent = this._getFile(id);
    let newMemoryFile = new MemoryFile(parent, filename, fileData, mimeType);
    return newMemoryFile.fileNode;
  }

  async writeFileNode(id, data) {
    let memoryFile = this._getFile(id);
    memoryFile.fileData = data;
    return memoryFile.fileNode;
  }

  async addDirectory(parentId, name) {
    let parent = this._getFile(parentId);
    let newMemoryDirectory = new MemoryDirectory(parent, name);
    return newMemoryDirectory.fileNode;
  }

  async rename(id, newName) {
    let memoryFile = this._getFile(id);
    memoryFile.rename(newName);
  }

  async delete(id) {
    let memoryFile = this._getFile(id);
    let parent = memoryFile.parent;
    parent.removeChild(memoryFile.name);
  }

  async copy(sourceId, targetParentId) {
    let sourceMemoryFile = this._getFile(sourceId);
    let targetMemoryFile = this._getFile(targetParentId);
    if (sourceMemoryFile.directory){
      new MemoryDirectory(targetMemoryFile, sourceMemoryFile.name);
    } else {
      new MemoryFile(targetMemoryFile, sourceMemoryFile.name,
                     copyArrayBuffer(sourceMemoryFile.fileData), sourceMemoryFile.mimeType);
    }
  }

  async move(sourceId, targetParentId) {
    let sourceMemoryFile = this._getFile(sourceId);
    sourceMemoryFile.parent = this._getFile(targetParentId);
  }

  async search(id, query) {
    throw new Error("Not implemented")
  }

  clone() {
    throw new Error("Not implemented")
  };
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-utils.html">utils</a></li></ul><h3>Classes</h3><ul><li><a href="AbstractFileStorage.html">AbstractFileStorage</a></li><li><a href="BaseFileSystem.html">BaseFileSystem</a></li><li><a href="BreadCrumb.html">BreadCrumb</a></li><li><a href="Column.html">Column</a></li><li><a href="DialogBrowser_DialogBrowser.html">DialogBrowser</a></li><li><a href="Element.html">Element</a></li><li><a href="FileAPIFileStorage.html">FileAPIFileStorage</a></li><li><a href="FileBrowser_FileBrowser.html">FileBrowser</a></li><li><a href="FileObject_FileObject.html">FileObject</a></li><li><a href="FileSystem.html">FileSystem</a></li><li><a href="Link_Link.html">Link</a></li><li><a href="LocalStorageFileStorage.html">LocalStorageFileStorage</a></li><li><a href="MemoryFileStorage.html">MemoryFileStorage</a></li><li><a href="NodeFileStorage.html">NodeFileStorage</a></li><li><a href="PhotoshelterStorage.html">PhotoshelterStorage</a></li><li><a href="Row.html">Row</a></li><li><a href="Table.html">Table</a></li></ul><h3>Mixins</h3><ul><li><a href="CacheMixin.html">CacheMixin</a></li><li><a href="DraggableMixin.html">DraggableMixin</a></li><li><a href="DroppableMixin.html">DroppableMixin</a></li><li><a href="ExecutableMixin.html">ExecutableMixin</a></li><li><a href="HiddenFileAPIMixin.html">HiddenFileAPIMixin</a></li><li><a href="HiddenReferenceLinkMixin.html">HiddenReferenceLinkMixin</a></li><li><a href="MountStorageMixin.html">MountStorageMixin</a></li><li><a href="StateMixin.html">StateMixin</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-DeveloperTutorial.html">Developers</a></li><li><a href="tutorial-UserInterfaceTutorial.html">User Interface</a></li></ul><h3>Global</h3><ul><li><a href="global.html#parseConfigFile">parseConfigFile</a></li><li><a href="global.html#updateConfigFile">updateConfigFile</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
