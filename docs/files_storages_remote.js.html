<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: files/storages/remote.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: files/storages/remote.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {parseJsonFile} from "../../utils.js";
import {FileNotFoundError, AbstractFileStorage} from "./base.js";


/**
 * A mixin that implements the methods addFile, addDirectory, rename, delete, copy, move and search
 * by writing to hidden virtual files. The backend must must support those operations.
 * @mixin HiddenFileAPIMixin
 * @param {AbstractFileStorage} fileStorageClass - A subclass of AbstractFileStorage.
 * @returns {AbstractFileStorage}
 */
export let HiddenFileAPIMixin = (fileStorageClass) => {
  return class extends fileStorageClass {
    constructor(...args) {
      super(...args);

      this.addDirectoryName = '.mkdir';
      this.addFileName = '.add';
      this.renameFileName = '.rename';
      this.deleteFileName = '.delete';
      this.moveFileName = '.move';
      this.searchFileName = '.search';
    }

    async _getAPIFileNode(dirId, name) {
      let directoryFile = await storage.readFileNode(dirId);
      let dirData = await parseJsonFile(directoryFile);
      let fileNode = dirData[name];
      if (!fileNode) {
        throw new FileNotFoundError(`API file ${name} not found.`);
      }
      return fileNode;
    }

    async addFile(parentId, file, filename, type) {
      let data = new FormData;
      data.append('file', file);
      if (filename) {
        data.append('name', filename);
      }

      let apiFileNode = await this._getAPIFileNode(parentId, this.addFileName);
      return await this.writeFileNode(apiFileNode.id, data);
    }

    async addDirectory(parentId, name) {
      let apiFileNode = await this._getAPIFileNode(parentId, this.addDirectoryName);
      return await this.writeFileNode(apiFileNode.id, name);
    }

    async rename(id, newName) {
      let data = new FormData;
      data.append('id', id);
      data.append('to', newName);

      let rootFileNode = await this.getRootFileNode();
      let apiFileNode = await this._getAPIFileNode(rootFileNode.id, this.renameFileName);
      await this.writeFileNode(apiFileNode.id, data);
    }

    async delete(id) {
      let rootFileNode = await this.getRootFileNode();
      let apiFileNode = await this._getAPIFileNode(rootFileNode.id, this.deleteFileName);
      await this.writeFileNode(apiFileNode.id, id);
    }

    async copy(sourceId, targetNodeId) {
      // TODO
      await super.copy(sourceId);
    }

    async move(sourceId, targetNodeId) {
      let apiFileNode = await this._getAPIFileNode(targetNodeId, this.moveFileName);
      await this.writeFileNode(apiFileNode, sourceId);
    }

    async search(id, query) {
      let apiFileNode = await this._getAPIFileNode(fileNodeId, this.searchFileName);
      let searchFile = await this.readFileNode(apiFileNode, {query: query});
      return parseJsonFile(searchFile);
    }
  };
};

/**
 * This storage uses an API that interacts with files via virtual files in each directory.
 * @extends AbstractFileStorage
 * @mixes HiddenFileAPIMixin
 */
export class FileAPIFileStorage extends HiddenFileAPIMixin(AbstractFileStorage) {
  constructor(baseUrl) {
    super();
    this._baseUrl = baseUrl;
    this.requestTimeout = 10;  // seconds

    let currentDateString = new Date().toISOString();
    this._rootFileNode = {
      id: "",
      name: 'root',
      url: this._baseUrl,
      directory: true,
      icon: null,
      size: 0,
      mimeType: 'application/json',
      lastModified: currentDateString,
      created: currentDateString
    };
  }

  clone() {
    let clonedFS = new this.constructor(this._baseUrl);
    clonedFS.changeDirectory(this.path, true);
    return clonedFS;
  }

  async getRootFileNode() {
    return this._rootFileNode;
  }

  async readFileNode(id, params) {
    params = params || {};
    return await this._ajax(this._baseUrl + id, params, 'GET');
  }

  async writeFileNode(id, data) {
    return await this._ajax(this._baseUrl + id, data, 'POST');
  }

  async _ajax(url, data, method) {
    return await new Promise((resolve, reject) => {
      data = data || {};

      method = method || 'GET';
      method = method.toUpperCase();
      if (method === 'GET' || method === 'DELETE') {
        url = url + this.constructor.encodeQueryData(data);
        data = null;
      }

      let request = new XMLHttpRequest();
      request.responseType = "arraybuffer";
      request.onreadystatechange = () => {
        if (request.readyState === XMLHttpRequest.DONE) {
          if (request.status === 0) {
            reject("An error has occurred");
          } else {
            let contentType = request.getResponseHeader('content-type');
            if (request.status >= 200 &amp;&amp; request.status &lt; 400) {
              resolve(request.response);
            } else {
              let errorText = new TextDecoder().decode(request.response);
              let errorMessage = `${request.status} error: `;
              if (contentType === 'application/json') {
                try {
                  let errorJson = JSON.parse(errorText);
                  for (let key in errorJson) {
                    errorMessage += `${key} - ${errorJson[key]}. `;
                  }
                  reject(new Error(errorMessage));
                } catch (e) {
                  reject("Error parsing response.");
                }
              } else {
                errorMessage += errorText;
                reject(new Error(errorMessage));
              }
            }
          }
        }
      };

      request.open(method, url, true);
      request.timeout = this.requestTimeout * 1000;
      if (!(data === null || data instanceof FormData || typeof data === "string" || data instanceof String)) {
        data = JSON.stringify(data);
        request.setRequestHeader("Content-Type", 'application/json');
      }
      this.constructor.configureAjaxRequest(request, method, url, data);
      request.send(data);
    });
  }

  static configureAjaxRequest(request, method, url, data) {
    if (!this.isCrossDomain(url)) {
      request.withCredentials = true;
      request.setRequestHeader("X-CSRFToken", this.csrfCookie);
    }
  }

  static getCookie(name) {
    let parts = document.cookie.split(`${name}=`);
    if (parts.length > 1) {
      parts = parts[1].split(';');
      return parts[0] || null;
    }
    return null;
  }

  static encodeQueryData(data) {
    let ret = [];
    for (let d in data) {
      if (data.hasOwnProperty(d)) {
        ret.push(encodeURIComponent(d) + '=' + encodeURIComponent(data[d]));
      }
    }
    return '?' + ret.join('&amp;');
  }

  static isCrossDomain(url) {
    let a = document.createElement("a");
    a.href = url;
    return window.location.protocol + '//' + window.location.host !==
      a.protocol + '//' + a.host;
  }

  static get csrfCookie() {
    return this.getCookie("csrftoken");
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-utils.html">utils</a></li></ul><h3>Classes</h3><ul><li><a href="AbstractFileStorage.html">AbstractFileStorage</a></li><li><a href="BaseFileSystem.html">BaseFileSystem</a></li><li><a href="BreadCrumb.html">BreadCrumb</a></li><li><a href="Column.html">Column</a></li><li><a href="DialogBrowser_DialogBrowser.html">DialogBrowser</a></li><li><a href="Element.html">Element</a></li><li><a href="FileAPIFileStorage.html">FileAPIFileStorage</a></li><li><a href="FileBrowser_FileBrowser.html">FileBrowser</a></li><li><a href="FileObject_FileObject.html">FileObject</a></li><li><a href="FileSystem.html">FileSystem</a></li><li><a href="Link_Link.html">Link</a></li><li><a href="LocalStorageFileStorage_LocalStorageFileStorage.html">LocalStorageFileStorage</a></li><li><a href="MemoryFileStorage_MemoryFileStorage.html">MemoryFileStorage</a></li><li><a href="PhotoshelterStorage_PhotoshelterStorage.html">PhotoshelterStorage</a></li><li><a href="Row.html">Row</a></li><li><a href="Table.html">Table</a></li></ul><h3>Mixins</h3><ul><li><a href="CacheMixin.html">CacheMixin</a></li><li><a href="DraggableMixin.html">DraggableMixin</a></li><li><a href="DroppableMixin.html">DroppableMixin</a></li><li><a href="ExecutableMixin.html">ExecutableMixin</a></li><li><a href="HiddenFileAPIMixin.html">HiddenFileAPIMixin</a></li><li><a href="HiddenReferenceLinkMixin.html">HiddenReferenceLinkMixin</a></li><li><a href="MountStorageMixin.html">MountStorageMixin</a></li><li><a href="StateMixin.html">StateMixin</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-DeveloperTutorial.html">Developers</a></li><li><a href="tutorial-UserInterfaceTutorial.html">User Interface</a></li></ul><h3>Global</h3><ul><li><a href="global.html#parseConfigFile">parseConfigFile</a></li><li><a href="global.html#updateConfigFile">updateConfigFile</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
